from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import or_
from typing import List, Optional
from datetime import datetime, date
from uuid import UUID

from app.database import get_db
from app.models.user import User
from app.models.employee import Employee
from app.core.security import get_current_user
from app.schemas.employee import EmployeeCreate, EmployeeUpdate, EmployeeResponse

router = APIRouter(prefix="/employees", tags=["Colaboradores"])

def employee_to_dict(employee: Employee) -> dict:
    emp_dict = employee.__dict__.copy()
    emp_dict.pop('_sa_instance_state', None)
    emp_dict['id'] = str(employee.id)
    if employee.area_id:
        emp_dict['area_id'] = str(employee.area_id)
    if employee.team_id:
        emp_dict['team_id'] = str(employee.team_id)
    if employee.manager_id:
        emp_dict['manager_id'] = str(employee.manager_id)
    if employee.user_id:
        emp_dict['user_id'] = str(employee.user_id)
    return emp_dict

@router.get("/", response_model=List[EmployeeResponse])
async def list_employees(
    skip: int = 0,
    limit: int = 100,
    search: Optional[str] = None,
    status: Optional[str] = Query(None, description="Filtrar por status"),
    team_id: Optional[UUID] = Query(None, description="Filtrar por time"),
    area_id: Optional[UUID] = Query(None, description="Filtrar por área"),
    cargo: Optional[str] = Query(None, description="Filtrar por cargo"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    query = db.query(Employee).options(joinedload(Employee.area))
    if search:
        query = query.filter(
            or_(
                Employee.nome.ilike(f"%{search}%"),
                Employee.email.ilike(f"%{search}%"),
                Employee.cargo.ilike(f"%{search}%")
            )
        )
    if status:
        query = query.filter(Employee.status == status)
    if team_id:
        query = query.filter(Employee.team_id == team_id)
    if cargo:
        query = query.filter(Employee.cargo.ilike(f"%{cargo}%"))
    if area_id:
        query = query.filter(Employee.area_id == area_id)
    query = query.order_by(Employee.nome)
    employees = query.offset(skip).limit(limit).all()
    return [employee_to_dict(emp) for emp in employees]

@router.get("/{employee_id}", response_model=EmployeeResponse)
async def get_employee(
    employee_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    employee = (
        db.query(Employee)
        .options(joinedload(Employee.area))
        .filter(Employee.id == employee_id)
        .first()
    )
    if not employee:
        raise HTTPException(status_code=404, detail="Colaborador não encontrado")
    return employee_to_dict(employee)

@router.post("/", response_model=EmployeeResponse, status_code=status.HTTP_201_CREATED)
async def create_employee(
    employee_data: EmployeeCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    if current_user.role not in ["admin", "diretoria", "gerente"]:
        raise HTTPException(status_code=403, detail="Sem permissão para criar colaboradores")
    if not employee_data.nome:
        raise HTTPException(status_code=400, detail="Nome é obrigatório")
    if not employee_data.email:
        raise HTTPException(status_code=400, detail="Email é obrigatório")
    if not employee_data.cargo:
        raise HTTPException(status_code=400, detail="Cargo é obrigatório")
    if not employee_data.status:
        employee_data.status = "ATIVO"
    if db.query(Employee).filter(Employee.email == employee_data.email).first():
        raise HTTPException(status_code=400, detail="Email já cadastrado")
    if employee_data.cpf:
        if db.query(Employee).filter(Employee.cpf == employee_data.cpf).first():
            raise HTTPException(status_code=400, detail="CPF já cadastrado")

    new_employee = Employee(
        nome=employee_data.nome,
        email=employee_data.email,
        cpf=employee_data.cpf,
        data_nascimento=employee_data.data_nascimento,
        telefone=employee_data.telefone,
        endereco=getattr(employee_data, "endereco", None),
        cargo=employee_data.cargo,
        data_admissao=employee_data.data_admissao or date.today(),
        salario=employee_data.salario,
        team_id=getattr(employee_data, "team_id", None),
        manager_id=getattr(employee_data, "manager_id", None),
        user_id=getattr(employee_data, "user_id", None),
        area_id=employee_data.area_id,
        status=employee_data.status or "ATIVO",
        ferias_dados={"dias_disponiveis": 30, "periodos": []},
        pdi_dados={"checks": [], "objetivos": []},
        reunioes_1x1={"historico": [], "proxima": None}
    )
    db.add(new_employee)
    db.commit()
    db.refresh(new_employee)
    return employee_to_dict(new_employee)

@router.put("/{employee_id}", response_model=EmployeeResponse)
async def update_employee(
    employee_id: UUID,
    employee_data: EmployeeUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    employee = db.query(Employee).filter(Employee.id == employee_id).first()
    if not employee:
        raise HTTPException(status_code=404, detail="Colaborador não encontrado")
    if current_user.role not in ["admin", "diretoria", "gerente"]:
        raise HTTPException(status_code=403, detail="Sem permissão para atualizar colaboradores")
    update_data = employee_data.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(employee, field, value)
    db.commit()
    db.refresh(employee)
    return employee_to_dict(employee)

@router.delete("/{employee_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_employee(
    employee_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    if current_user.role not in ["admin", "diretoria"]:
        raise HTTPException(status_code=403, detail="Apenas administradores podem deletar colaboradores")
    employee = db.query(Employee).filter(Employee.id == employee_id).first()
    if not employee:
        raise HTTPException(status_code=404, detail="Colaborador não encontrado")
    db.delete(employee)
    db.commit()
    return None

@router.get("/{employee_id}/pdi")
async def get_employee_pdi(
    employee_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    employee = db.query(Employee).filter(Employee.id == employee_id).first()
    if not employee:
        raise HTTPException(status_code=404, detail="Colaborador não encontrado")
    return {
        "employee_id": str(employee.id),
        "employee_nome": employee.nome,
        "pdi_dados": employee.pdi_dados or {"checks": [], "objetivos": []},
        "data_proximo_pdi": employee.data_proximo_pdi
    }

@router.put("/{employee_id}/pdi")
async def update_employee_pdi(
    employee_id: UUID,
    pdi_data: dict,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    employee = db.query(Employee).filter(Employee.id == employee_id).first()
    if not employee:
        raise HTTPException(status_code=404, detail="Colaborador não encontrado")
    employee.pdi_dados = pdi_data
    employee.data_proximo_pdi = pdi_data.get("data_proximo_pdi")
    db.commit()
    db.refresh(employee)
    return {"message": "PDI atualizado com sucesso", "pdi": employee.pdi_dados}

@router.get("/{employee_id}/ferias")
async def get_employee_ferias(
    employee_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    employee = db.query(Employee).filter(Employee.id == employee_id).first()
    if not employee:
        raise HTTPException(status_code=404, detail="Colaborador não encontrado")
    return {
        "employee_id": str(employee.id),
        "employee_nome": employee.nome,
        "ferias_dados": employee.ferias_dados or {"dias_disponiveis": 30, "periodos": []}
    }

@router.get("/stats/overview")
async def get_employees_stats(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    total = db.query(Employee).count()
    ativos = db.query(Employee).filter(Employee.status == "ATIVO").count()
    ferias = db.query(Employee).filter(Employee.status == "FERIAS").count()
    afastados = db.query(Employee).filter(Employee.status == "AFASTADO").count()
    desligados = db.query(Employee).filter(Employee.status == "DESLIGADO").count()
    return {
        "total": total,
        "ativos": ativos,
        "ferias": ferias,
        "afastados": afastados,
        "desligados": desligados,
        "timestamp": datetime.now().isoformat()
    }
